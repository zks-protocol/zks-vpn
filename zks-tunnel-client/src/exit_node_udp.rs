//! Exit Node UDP Mode for Multi-Hop VPN\n//!\n//! Second hop in the Faisal Swarm multi-hop topology.\n//! Accepts UDP connections from Entry Node (VPS1) and forwards to Internet.\n\nuse tokio::net::UdpSocket;\nuse tracing::{debug, error, info};\n\n/// Run as Exit Node in UDP mode (Multi-Hop - Second Hop)\n///\n/// Instead of WebSocket from relay, accepts UDP connections from Entry Node (VPS1).\n/// Creates TUN device and forwards IP packets to/from Internet.\npub async fn run_exit_node_udp(\n    listen_port: u16,\n) -\u003e Result\u003c(), Box\u003cdyn std::error::Error + Send + Sync\u003e\u003e {\n    info!(\"╔══════════════════════════════════════════════════════════════╗\");\n    info!(\"║      ZKS Exit Node UDP - Multi-Hop Second Hop                ║\");\n    info!(\"╠══════════════════════════════════════════════════════════════╣\");\n    info!(\"║  Listen: 0.0.0.0:{}                                       \", listen_port);\n    info!(\"║  Mode:   Accept UDP from Entry Node                          ║\");\n    info!(\"╚══════════════════════════════════════════════════════════════╝\");\n\n    // Create TUN device for packet forwarding (10.0.85.2 for exit peer)\n    info!(\"Creating TUN device for VPN forwarding...\");\n\n    let device = tun_rs::DeviceBuilder::new()\n        .ipv4(std::net::Ipv4Addr::new(10, 0, 85, 2), 24, None)\n        .mtu(1400)\n        .build_async()?;\n\n    info!(\"✅ TUN device created (10.0.85.2/24)\");\n\n    // Enable IP forwarding on Linux\n    #[cfg(target_os = \"linux\")]\n    {\n        let _ = std::process::Command::new(\"sysctl\")\n            .args([\"-w\", \"net.ipv4.ip_forward=1\"])\n            .output();\n        info!(\"Enabled IP forwarding\");\n\n        // Setup NAT\n        let _ = std::process::Command::new(\"iptables\")\n            .args([\n                \"-t\",\n                \"nat\",\n                \"-A\",\n                \"POSTROUTING\",\n                \"-s\",\n                \"10.0.85.0/24\",\n                \"-j\",\n                \"MASQUERADE\",\n            ])\n            .output();\n        info!(\"Configured NAT for 10.0.85.0/24\");\n    }\n\n    // Bind UDP socket\n    let socket = std::sync::Arc::new(UdpSocket::bind(format!(\"0.0.0.0:{}\", listen_port)).await?);\n    info!(\"✅ UDP socket bound to 0.0.0.0:{}\", listen_port);\n\n    // Track Entry Node address (will be set when we receive first packet)\n    let entry_node_addr = std::sync::Arc::new(tokio::sync::RwLock::new(None::\u003cstd::net::SocketAddr\u003e));\n\n    info!(\"⏳ Waiting for Entry Node connection...\");\n\n    // Task: TUN → UDP (outbound to Internet → back to Entry Node)\n    let tun_to_udp = {\n        let device = device.clone();\n        let socket = socket.clone();\n        let entry_node_addr = entry_node_addr.clone();\n\n        tokio::spawn(async move {\n            let mut buf = vec![0u8; 65535];\n\n            loop {\n                match device.recv(\u0026mut buf).await {\n                    Ok(n) =\u003e {\n                        // Read packet from TUN (Internet response)\n                        let packet = \u0026buf[..n];\n\n                        // Send to Entry Node if connected\n                        let addr_lock = entry_node_addr.read().await;\n                        if let Some(addr) = *addr_lock {\n                            if let Err(e) = socket.send_to(packet, addr).await {\n                                error!(\"Failed to send to Entry Node: {}\", e);\n                            } else {\n                                debug!(\"← Internet → Entry: {} bytes\", n);\n                            }\n                        }\n                    }\n                    Err(e) =\u003e {\n                        error!(\"TUN read error: {}\", e);\n                        break;\n                    }\n                }\n            }\n        })\n    };\n\n    // Task: UDP → TUN (inbound from Entry Node → to Internet)\n    let udp_to_tun = {\n        let device = device.clone();\n        let socket = socket.clone();\n        let entry_node_addr = entry_node_addr.clone();\n\n        tokio::spawn(async move {\n            let mut buf = vec![0u8; 65535];\n\n            loop {\n                match socket.recv_from(\u0026mut buf).await {\n                    Ok((n, addr)) =\u003e {\n                        // First packet from Entry Node - remember address\n                        {\n                            let mut addr_lock = entry_node_addr.write().await;\n                            if addr_lock.is_none() {\n                                info!(\"✅ Entry Node connected: {}\", addr);\n                                *addr_lock = Some(addr);\n                            }\n                        }\n\n                        // Forward packet to TUN (to Internet)\n                        let packet = \u0026buf[..n];\n                        if let Err(e) = device.send(packet).await {\n                            error!(\"TUN write error: {}\", e);\n                        } else {\n                            debug!(\"→ Entry → Internet: {} bytes\", n);\n                        }\n                    }\n                    Err(e) =\u003e {\n                        error!(\"UDP recv error: {}\", e);\n                        break;\n                    }\n                }\n            }\n        })\n    };\n\n    // Wait for both tasks\n    tokio::select! {\n        _ = tun_to_udp =\u003e {\n            error!(\"TUN to UDP task ended\");\n        }\n        _ = udp_to_tun =\u003e {\n            error!(\"UDP to TUN task ended\");\n        }\n    }\n\n    Ok(())\n}\n
