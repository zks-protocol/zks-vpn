(*
 * ZKS Protocol - ProVerif Formal Verification Model (ENHANCED v3)
 * 
 * Protocol: ZKS (Zero-Knowledge Swarm) Handshake with Mutual Authentication
 * Author: Md. Wasif Faisal, BRAC University
 * Date: December 2025
 * Version: 3.0 - Fixed authentication queries with key confirmation
 * 
 * SECURITY FIXES v3:
 * 1. ResponderAccepted now requires key confirmation from initiator
 * 2. 3-message handshake with proper authentication ordering
 * 3. Authentication queries match actual protocol guarantees
 *)

(* ============================================== *)
(*                    TYPES                       *)
(* ============================================== *)

type skey.       (* Secret/private key *)
type pkey.       (* Public key *)
type key.        (* Symmetric key *)
type nonce.      (* Nonce/counter *)

(* ============================================== *)
(*                  CHANNELS                      *)
(* ============================================== *)

free c: channel.                     (* Public network channel *)
free secure_channel: channel [private]. (* For out-of-band key distribution *)

(* ============================================== *)
(*          CRYPTOGRAPHIC PRIMITIVES              *)
(* ============================================== *)

(* --- Public Key Derivation --- *)
fun pk(skey): pkey.

(* --- X25519 Diffie-Hellman --- *)
fun x25519(skey, pkey): key.
equation forall x: skey, y: skey; x25519(x, pk(y)) = x25519(y, pk(x)).

(* --- Kyber768 KEM (abstracted) --- *)
fun kyber_pk(skey): pkey.
fun kyber_encap(pkey): bitstring.       (* Returns ciphertext *)
fun kyber_ss(skey, bitstring): key.     (* Shared secret from decapsulation *)
fun kyber_ss_enc(pkey, bitstring): key. (* Shared secret from encapsulation *)

(* KEM correctness: encapsulator and decapsulator derive same shared secret *)
equation forall sk: skey, ct: bitstring; 
  kyber_ss(sk, kyber_encap(kyber_pk(sk))) = kyber_ss_enc(kyber_pk(sk), kyber_encap(kyber_pk(sk))).

(* --- HKDF Key Derivation --- *)
fun hkdf(key, key, bitstring): key.
fun hkdf3(key, key, key, key, bitstring): key.

(* --- Wasif-Vernam Encryption (XOR-based, modeled as IND-CPA secure) --- *)
fun wv_encrypt(bitstring, key, nonce): bitstring.
reduc forall m: bitstring, k: key, n: nonce; 
  wv_decrypt(wv_encrypt(m, k, n), k, n) = m.

(* Key rotation function *)
fun wv_rotate_key(key, bitstring): key.

(* --- AEAD for handshake (ChaCha20-Poly1305 abstracted) --- *)
fun aead_encrypt(bitstring, key, nonce): bitstring.
reduc forall m: bitstring, k: key, n: nonce; 
  aead_decrypt(aead_encrypt(m, k, n), k, n) = m.

(* --- Timestamps --- *)
fun timestamp(): bitstring.

(* --- MAC for authentication proof --- *)
fun hmac(bitstring, key): bitstring.

(* ============================================== *)
(*           SECURITY QUERIES                     *)
(* ============================================== *)

free session_secret: bitstring [private].
free initiator_identity: bitstring [private].
free responder_identity: bitstring [private].
free transport_data_1: bitstring [private].
free transport_data_2: bitstring [private].
free transport_data_3: bitstring [private].

(* Data confidentiality queries *)
query attacker(session_secret).
query attacker(transport_data_1).
query attacker(transport_data_2).
query attacker(transport_data_3).
query attacker(initiator_identity).
query attacker(responder_identity).

(* Authentication events *)
event InitiatorStarted(pkey, pkey).
event InitiatorConfirmed(pkey, pkey, key).
event ResponderSentReply(pkey, pkey, key).
event ResponderAccepted(pkey, pkey, key).
event SessionEstablished(pkey, pkey, key).

(* Authentication queries - FIXED: match actual protocol semantics *)
(* Query 1: Responder accepts only after receiving valid key confirmation *)
query pkI: pkey, pkR: pkey, k: key; 
  event(ResponderAccepted(pkI, pkR, k)) ==> event(InitiatorConfirmed(pkI, pkR, k)).

(* Query 2: Key confirmation requires initiator to have started *)
query pkI: pkey, pkR: pkey, k: key;
  event(InitiatorConfirmed(pkI, pkR, k)) ==> event(InitiatorStarted(pkI, pkR)).

(* Query 3: Session establishment implies initiator started *)
query pkI: pkey, pkR: pkey, k: key;
  inj-event(SessionEstablished(pkI, pkR, k)) ==> inj-event(InitiatorStarted(pkI, pkR)).

(* ============================================== *)
(*     ZKS HANDSHAKE PROTOCOL (3-MESSAGE)         *)
(* ============================================== *)

(*
 * SECURITY FIX v3: 3-Message Protocol with Key Confirmation
 * 
 * Message 1: Initiator -> Responder
 * +--------+------------+-------------+------------------+
 * | Type   | Ephemeral  | Kyber PK    | Encrypted        |
 * | 0x01   | X25519(32) | (1184 bytes)| Static + TS + ID |
 * +--------+------------+-------------+------------------+
 *
 * Message 2: Responder -> Initiator  
 * +--------+------------+-------------+-------------------------+
 * | Type   | Ephemeral  | Kyber CT    | Encrypted Response      |
 * | 0x02   | X25519(32) | (1088 bytes)| Identity + Auth Proof   |
 * +--------+------------+-------------+-------------------------+
 *
 * Message 3: Initiator -> Responder (KEY CONFIRMATION)
 * +--------+---------------------------------------------------+
 * | Type   | HMAC(session_key, "initiator_confirmed")          |
 * | 0x03   | Proves initiator has skI and computed session key |
 * +--------+---------------------------------------------------+
 *)

let Initiator(skI: skey, pkI: pkey, pkR: pkey) =
  (* Generate ephemeral keys *)
  new eiX: skey;
  new eiK: skey;
  let EiX = pk(eiX) in
  let EiK = kyber_pk(eiK) in
  
  (* Derive encryption key: DH(ephemeral, responder_static) *)
  let k_enc1 = x25519(eiX, pkR) in
  
  (* Encrypt initiator's static public key + timestamp + identity *)
  new n1: nonce;
  let ts = timestamp() in
  let encrypted_static = aead_encrypt((pkI, ts, initiator_identity), k_enc1, n1) in
  
  (* Signal: Initiator has started *)
  event InitiatorStarted(pkI, pkR);
  
  (* Send Message 1 *)
  out(c, (EiX, EiK, encrypted_static, n1));
  
  (* Receive Message 2 *)
  in(c, (ErX: pkey, kyber_ct: bitstring, encrypted_resp: bitstring, n2: nonce, auth_proof: bitstring));
  
  (* Derive shared secrets *)
  let dh1 = x25519(eiX, ErX) in
  let dh2 = x25519(eiX, pkR) in
  let dh3 = x25519(skI, ErX) in  (* CRITICAL: Uses initiator's long-term key *)
  let ss_kyber = kyber_ss(eiK, kyber_ct) in
  
  (* Master secret: includes both identities *)
  let master_key = hkdf3(dh1, dh2, dh3, ss_kyber, (EiX, ErX, pkI, pkR)) in
  
  (* Verify authentication proof from responder *)
  let expected_proof = hmac((ErX, EiX, pkR, pkI), master_key) in
  if auth_proof = expected_proof then
  
  (* Derive transport keys *)
  let t_send = hkdf(master_key, dh1, (pkI, pkR, EiX, ErX)) in
  let t_recv = hkdf(master_key, dh2, (pkR, pkI, ErX, EiX)) in
  
  (* Send Message 3: Key confirmation *)
  let key_confirm = hmac((EiX, ErX, pkI, pkR), master_key) in
  event InitiatorConfirmed(pkI, pkR, master_key);
  out(c, key_confirm);
  
  (* Session established after mutual verification *)
  event SessionEstablished(pkI, pkR, master_key);
  
  (* Transport encryption *)
  new n3: nonce;
  new n4: nonce;
  new n5: nonce;
  new n6: nonce;
  
  out(c, wv_encrypt(session_secret, t_send, n3));
  out(c, wv_encrypt(transport_data_1, t_send, n4));
  out(c, wv_encrypt(transport_data_2, t_send, n5));
  
  let t_send_rotated = wv_rotate_key(t_send, (n5, EiX)) in
  out(c, wv_encrypt(transport_data_3, t_send_rotated, n6)).


let Responder(skR: skey, pkR: pkey, expected_pkI: pkey) =
  (* Receive Message 1 *)
  in(c, (EiX: pkey, EiK: pkey, encrypted_static: bitstring, n1: nonce));
  
  (* Derive decryption key *)
  let k_dec1 = x25519(skR, EiX) in
  
  (* Decrypt initiator's identity *)
  let (pkI: pkey, ts: bitstring, id: bitstring) = aead_decrypt(encrypted_static, k_dec1, n1) in
  
  (* Verify initiator is from expected set *)
  if pkI = expected_pkI then
  
  (* Generate ephemeral keys *)
  new erX: skey;
  let ErX = pk(erX) in
  
  (* Kyber encapsulation *)
  let kyber_ct = kyber_encap(EiK) in
  let ss_kyber = kyber_ss_enc(EiK, kyber_ct) in
  
  (* Derive shared secrets *)
  let dh1 = x25519(erX, EiX) in
  let dh2 = x25519(skR, EiX) in
  let dh3 = x25519(erX, pkI) in  (* Uses initiator's claimed public key *)
  
  (* Master secret - includes both identities *)
  let master_key = hkdf3(dh1, dh2, dh3, ss_kyber, (EiX, ErX, pkI, pkR)) in
  
  (* Create authentication proof *)
  let auth_proof = hmac((ErX, EiX, pkR, pkI), master_key) in
  
  (* Derive transport keys *)
  let t_recv = hkdf(master_key, dh1, (pkI, pkR, EiX, ErX)) in
  let t_send = hkdf(master_key, dh2, (pkR, pkI, ErX, EiX)) in
  
  (* Encrypt responder identity *)
  new n2: nonce;
  let encrypted_resp = aead_encrypt(responder_identity, master_key, n2) in
  
  (* Signal: Responder sent reply (but not yet accepted) *)
  event ResponderSentReply(pkI, pkR, master_key);
  
  (* Send Message 2 *)
  out(c, (ErX, kyber_ct, encrypted_resp, n2, auth_proof));
  
  (* Receive Message 3: Key confirmation from initiator *)
  in(c, key_confirm: bitstring);
  
  (* Verify key confirmation - proves initiator has skI *)
  let expected_confirm = hmac((EiX, ErX, pkI, pkR), master_key) in
  if key_confirm = expected_confirm then
  
  (* NOW responder can trust initiator has skI *)
  event ResponderAccepted(pkI, pkR, master_key);
  event SessionEstablished(pkI, pkR, master_key);
  
  (* Receive encrypted data *)
  in(c, encrypted_data: bitstring).


(* ============================================== *)
(*              MAIN PROCESS                      *)
(* ============================================== *)

process
  (* Generate long-term keys *)
  new skI: skey;
  new skR: skey;
  let pkI = pk(skI) in
  let pkR = pk(skR) in
  
  (* Publish public keys *)
  out(c, pkI);
  out(c, pkR);
  
  (* Run protocol instances *)
  (
    Initiator(skI, pkI, pkR) | 
    Responder(skR, pkR, pkI) |
    
    (* Multiple sessions with verified key pairs *)
    !Initiator(skI, pkI, pkR) |
    !Responder(skR, pkR, pkI)
  )

