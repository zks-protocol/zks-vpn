/*
 * ZKS Protocol - Tamarin Formal Verification Model (FIXED v4)
 * 
 * Protocol: ZKS (Zero-Knowledge Swarm) Handshake with Mutual Authentication
 * Author: Md. Wasif Faisal, BRAC University
 * Date: December 2025
 * Version: 4.0 - Fixed identity verification in Responder rule
 * 
 * KEY INSIGHT: The Responder must receive BOTH the ephemeral key AND the 
 * encrypted identity, and must verify that decryption produces the expected
 * initiator identity ($I). This is enforced by pattern matching in the In() fact.
 * 
 * The key security property: An attacker cannot forge a valid encrypted identity
 * without knowing either the initiator's private key (to create valid g^ei) 
 * or the responder's private key (to decrypt).
 */

theory ZKS_Handshake
begin

builtins: diffie-hellman, symmetric-encryption, hashing

/*
 * ============================================
 *              KEY INFRASTRUCTURE
 * ============================================
 */

// Long-term keypair generation
rule Generate_Keypair:
    [ Fr(~sk) ]
  -->
    [ !Ltk($A, ~sk), !Pk($A, 'g'^~sk), Out('g'^~sk) ]

// Register expected peers (for mutual authentication)
rule Register_Peer:
    [ !Pk($I, pkI), !Pk($R, pkR) ]
  -->
    [ !ExpectedPeer($R, $I, pkI), !ExpectedPeer($I, $R, pkR) ]

// Reveal long-term keys (for forward secrecy analysis)
rule Reveal_Ltk:
    [ !Ltk(A, sk) ]
  --[ Reveal(A) ]->
    [ Out(sk) ]

/*
 * ============================================
 *   ZKS HANDSHAKE PROTOCOL (FIXED v4)
 * ============================================
 * 
 * Message 1: I -> R: g^ei, senc(<$I, timestamp>, DH(ei, pkR))
 * Message 2: R -> I: g^er, h(<sessionKey, g^er, g^ei, 'auth'>)
 * 
 * CRITICAL FIX: The Responder rule now explicitly requires the encrypted
 * identity to decrypt to <$I, ts> where $I is the expected initiator.
 * This is enforced by including the encryption in the pattern match.
 */

// Initiator sends first message
rule Initiator_1:
    let
        EiPk = 'g'^~ei                      // Ephemeral public key
        pkR = 'g'^skR                       // Responder's public key
        k1 = pkR^~ei                        // DH(ei, pkR)
        encryptedId = senc(<$I, ~ts>, k1)   // Encrypted initiator identity
        m1 = <EiPk, encryptedId>
    in
    [ Fr(~ei), Fr(~ts), !Ltk($I, ~skI), !Pk($R, pkR), !ExpectedPeer($I, $R, pkR) ]
  --[ InitiatorStart($I, $R, ~ei) ]->
    [ Out(m1), 
      St_Initiator_1($I, $R, ~skI, ~ei, pkR, ~ts) ]

// Responder receives first message
// FIXED: Uses pattern matching to verify encrypted identity
rule Responder_1:
    let
        EiPk = 'g'^ei
        pkI = 'g'^skI
        ErPk = 'g'^~er
        
        // Key for decryption: DH(ei, skR)
        k1 = EiPk^~skR
        
        // The encrypted identity MUST decrypt to <$I, ts>
        // This pattern in the In() forces the encryption to be valid
        encId = senc(<$I, ts>, k1)
        
        // Session key includes both identities (SECURITY FIX from v2)
        dh1 = EiPk^~er
        dh2 = EiPk^~skR
        dh3 = pkI^~er
        sessionKey = h(<dh1, dh2, dh3, pkI, 'g'^~skR>)
        
        // Authentication proof
        authProof = h(<sessionKey, ErPk, EiPk, 'responder_auth'>)
        m2 = <ErPk, authProof>
    in
    // CRITICAL: The In() pattern now includes the EXPECTED encrypted form
    // This means the message must contain a valid encryption of <$I, ts>
    [ In(<EiPk, encId>),
      Fr(~er),
      !Ltk($R, ~skR),
      !Pk($I, pkI),
      !ExpectedPeer($R, $I, pkI) ]
  --[ ResponderAccept($R, $I, sessionKey),
      SessionKey($R, $I, sessionKey),
      Honest($I), Honest($R) ]->
    [ Out(m2),
      St_Responder_1($R, $I, ~skR, ~er, EiPk, sessionKey) ]

// Initiator receives response, verifies MAC, computes session key
rule Initiator_2:
    let
        ErPk = 'g'^er
        pkR = 'g'^skR
        pkI = 'g'^~skI
        
        // Session key includes both identities
        dh1 = ErPk^~ei
        dh2 = pkR^~ei
        dh3 = ErPk^~skI
        sessionKey = h(<dh1, dh2, dh3, pkI, pkR>)
        
        // Verify the MAC (must match what responder sent)
        expectedMac = h(<sessionKey, ErPk, 'g'^~ei, 'responder_auth'>)
    in
    [ In(<ErPk, expectedMac>),
      St_Initiator_1($I, $R, ~skI, ~ei, pkR, ts) ]
  --[ InitiatorComplete($I, $R, sessionKey),
      SessionKey($I, $R, sessionKey),
      Honest($I), Honest($R),
      Secret($I, $R, sessionKey) ]->
    [ St_Initiator_2($I, $R, sessionKey) ]

/*
 * ============================================
 *          SECURITY PROPERTIES
 * ============================================
 */

// Secrecy: Session key is secret unless parties are compromised
lemma session_key_secrecy:
  "All I R k #i. 
    Secret(I, R, k) @ i 
    ==> (not Ex #j. K(k) @ j)
        | (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

// Authentication: Responder only accepts if initiator genuinely started
// with the SAME ephemeral key
lemma initiator_authentication:
  "All R I k #i.
    ResponderAccept(R, I, k) @ i
    ==> (Ex ei #j. InitiatorStart(I, R, ei) @ j & j < i)
        | (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

// Injective agreement: Each session key is used only once per party
lemma injective_agreement:
  "All I R k #i #j.
    InitiatorComplete(I, R, k) @ i &
    InitiatorComplete(I, R, k) @ j
    ==> #i = #j"

// Forward secrecy: Key compromise doesn't reveal session key unless
// it happened (or can be used to decrypt recorded sessions)
lemma forward_secrecy:
  "All I R k #i #j.
    SessionKey(I, R, k) @ i &
    K(k) @ j
    ==> (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

// Uniqueness: Different sessions produce different keys
lemma session_key_uniqueness:
  "All I1 R1 I2 R2 k #i #j.
    SessionKey(I1, R1, k) @ i &
    SessionKey(I2, R2, k) @ j &
    not (#i = #j)
    ==> (I1 = I2 & R1 = R2)
        | (Ex #r. Reveal(I1) @ r)
        | (Ex #r. Reveal(R1) @ r)"

// Mutual authentication: SessionKey implies both parties are genuine
lemma mutual_authentication:
  "All I R k #i.
    SessionKey(I, R, k) @ i & Honest(I) @ i & Honest(R) @ i
    ==> (Ex ei #j. InitiatorStart(I, R, ei) @ j & j < i)
        | (Ex #r. Reveal(I) @ r)
        | (Ex #r. Reveal(R) @ r)"

end
